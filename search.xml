<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>删除单链表中所有值为x的数据元素</title>
      <link href="/2022/05/15/%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAx%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
      <url>/2022/05/15/%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E5%80%BC%E4%B8%BAx%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>算法思路</strong>：==定义两个指针r与p，其中让p指针始终在r指针的前面==,即p = r-&gt;next 。让两个指针在链表中从头结点开始移动，如果p指针所指向结点的数据域的值与给定的值x相等,就要删除 。因为指针r指向该结点的前驱结点，所以我们可以轻松的进行删除操作 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deletex</span> <span class="params">(LinkList* head, <span class="type">int</span>* x)</span></span><br><span class="line"><span class="comment">//head为头指针，LinkList为单链表的存储类型 </span></span><br><span class="line">&#123;</span><br><span class="line">LinkList*r;</span><br><span class="line">r = head; </span><br><span class="line"><span class="keyword">while</span> (r-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//当指针r遍历整个链表后，退出while循环</span></span><br><span class="line">   &#123;</span><br><span class="line">     LinkList* p = r-&gt;next; </span><br><span class="line">  <span class="keyword">if</span> (p-&gt;data == (*x))</span><br><span class="line"><span class="comment">//判断指针p所指向的节点的数据域的值是否与x相等  </span></span><br><span class="line">    &#123;</span><br><span class="line">    r-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果相等，则删除该节点        </span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  r = r-&gt;next;</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//如果不相等，则指针继续移动  </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n将值为%d的元素删除后，&quot;</span>, (*x));</span><br><span class="line">print (head);</span><br><span class="line"><span class="comment">//将该链表中所有结点的数据域的值依次打印出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用一个结点个数为4的单链表举例（头结点不存放元素）</strong></p><p>它的原始形态：<br><img src="https://img-blog.csdnimg.cn/20210526231440140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>执行语句r = head;和 LinkList* p = r-&gt;next;后<br><img src="https://img-blog.csdnimg.cn/20210526231554618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当p-&gt;data == (*x)不成立时，指针r, p都要往后移动<br><img src="https://img-blog.csdnimg.cn/20210526233940127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当p-&gt;data == (*x)成立时，则要删除指针p所指向的结点<br><img src="https://img-blog.csdnimg.cn/20210526234101468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>=======================================<br>下面是完整的代码，用于验证我们的算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//运用malloc函数需要添加该文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"> &#125; LinkList;</span><br><span class="line"><span class="comment">//定义LinkList为struct node的结构体类型，Linklist相当于是struct node的别名</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//该函数的作用是将链表中各个元素的值依次打印出来 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span> <span class="params">(LinkList* head)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList* r;</span><br><span class="line"><span class="comment">//先定义LinkList*的类型的指针变量 </span></span><br><span class="line">r = head-&gt;next;</span><br><span class="line"><span class="comment">//给这个变量分配空间，r指向第一个节点的位置 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n该线性表为：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%5d&quot;</span>, r-&gt;data);</span><br><span class="line">r = r-&gt;next;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletex</span> <span class="params">(LinkList* head, <span class="type">int</span>* x)</span></span><br><span class="line"><span class="comment">//head为头指针，LinkList单链表的存储类型 </span></span><br><span class="line">&#123;</span><br><span class="line">LinkList*r;</span><br><span class="line">r = head; </span><br><span class="line"><span class="keyword">while</span> (r-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//当指针r遍历整个链表后，退出while循环</span></span><br><span class="line">   &#123;</span><br><span class="line">     LinkList* p = r-&gt;next; </span><br><span class="line">  <span class="keyword">if</span> (p-&gt;data == (*x))</span><br><span class="line"><span class="comment">//判断指针p所指向的节点的数据域的值是否与x相等  </span></span><br><span class="line">    &#123;</span><br><span class="line">    r-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span> (p);</span><br><span class="line"><span class="comment">//删除指针p所指向的结点    </span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果相等，则删除该节点        </span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  r = r-&gt;next;</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//如果不相等，则指针继续移动  </span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n将值为%d的元素删除后，&quot;</span>, (*x));</span><br><span class="line">print (head);</span><br><span class="line"><span class="comment">//将该链表中所有结点的数据域的值依次打印出来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, r, len = <span class="number">5</span>;</span><br><span class="line"> LinkList* head;</span><br><span class="line">head = (LinkList*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line"><span class="comment">//下面是尾插法创建单链表</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LinkList* q,* tail;</span><br><span class="line">    tail = head;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">q = (LinkList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入第%d位元素的值：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data); </span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail-&gt;next = q;</span><br><span class="line">tail = q; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">print (head);</span><br><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line">deletex (head, &amp;x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">请输入第1位元素的值：4</span></span><br><span class="line"><span class="comment">请输入第2位元素的值：1</span></span><br><span class="line"><span class="comment">请输入第3位元素的值：2</span></span><br><span class="line"><span class="comment">请输入第4位元素的值：3</span></span><br><span class="line"><span class="comment">请输入第5位元素的值：4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">该线性表为：    4    1    2    3    4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将值为4的元素删除后，</span></span><br><span class="line"><span class="comment">该线性表为：    1    2    3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_52607834/article/details/115922172">创建单链表用到了尾插法，如果对这个算法不够了解的小伙伴可以看看我写的另一篇文章，里面有详细的讲解</a></p><blockquote><p>如果有更好的算法，欢迎小伙伴在评论区留言，一起交流学习！！！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>putchar和getchar函数的使用</title>
      <link href="/2022/05/15/putchar%E5%92%8Cgetchar%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/15/putchar%E5%92%8Cgetchar%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="putchar函数的三种用法"><a href="#putchar函数的三种用法" class="headerlink" title="putchar函数的三种用法"></a>putchar函数的三种用法</h1><p>（1）若putchar的括号里面是==用单引号括起来的单个字符==，则输出结果就是该字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span> (<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果： a9</span></span><br></pre></td></tr></table></figure><p>（2）若putchar的括号里面是某个字符变量，则输出的是该变量所对应的字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="built_in">putchar</span> (ch);</span><br><span class="line"><span class="comment">//这行代码等价于printf (&quot;%c&quot;, ch);</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//结果：a</span></span><br></pre></td></tr></table></figure><p>（3）若putchar的括号里面是一个0~127之间的一个整数，则它会被自动视为某个字符的ASCII码，输出该ASCII码所对应的字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span> (<span class="number">120</span>);</span><br><span class="line"><span class="built_in">putchar</span> (<span class="number">55</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：x7</span></span><br></pre></td></tr></table></figure><h1 id="getchar函数的用法"><a href="#getchar函数的用法" class="headerlink" title="getchar函数的用法"></a>getchar函数的用法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ch; </span><br><span class="line"><span class="comment">//这里的int可改为float，double和char等，不影响结果</span></span><br><span class="line">ch = getchar ();</span><br><span class="line"><span class="built_in">putchar</span> (ch);</span><br><span class="line"><span class="comment">/*上面的代码等价于</span></span><br><span class="line"><span class="comment"> char ch;</span></span><br><span class="line"><span class="comment"> scanf (&quot;%c&quot;, &amp;ch);</span></span><br><span class="line"><span class="comment"> printf (&quot;%c&quot;, ch); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2022/05/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
      <url>/2022/05/15/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h3><p> 哈夫曼树又称为最优二叉树，它是由n个带权值的叶子结点所构成的所有二叉树中==带权路径长度==最小的二叉树<br> (树的带权路径长度：树中所有叶子结点的权值乘以相应的树根结点的路径长度之和)</p><p> 例如：对于权值分别为2, 3, 4, 6的叶子结点，可以构成如下图所示的二叉树<img src="https://img-blog.csdnimg.cn/20210606162418790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以分别算出这些二叉树的带权路径长度<br>树a的带权路径长度 : 2×2+3×2+4×2+6×2=30<br>树b的带权路径长度 : 2×1+3×2+4×3+6×3=38<br>树c的带权路径长度 : 2×3+3×3+4×2+6×1=29</p><p>所以在这3棵二叉树中，树c的带权路径长度最小</p><h3 id="哈夫曼树的构造思想"><a href="#哈夫曼树的构造思想" class="headerlink" title="哈夫曼树的构造思想"></a>哈夫曼树的构造思想</h3><p>（1）用n棵只有一个根结点的二叉树存放给定的n个权值，它们共同构造成一个森林<br>（2）在森林中选取两棵树根结点的权值最小的二叉树作为左右子树构造成一棵新的二叉树，新二叉树的根结点的权值为原来两棵树根结点的权值之和<br>（3）将上面选择的这两棵根结点的权值最小的二叉树从森林中删除，并将新构造的二叉树加入到森林中<br>（4）重复上面的(2) (3),直到森林中只有一棵二叉树为止，这棵二叉树就是哈夫曼树</p><p>假设有一组权值{2, 3, 6, 9},下面我们利用这组权值演示构造哈夫曼树的过程<br><img src="https://img-blog.csdnimg.cn/20210606165633202.png" alt="在这里插入图片描述"><br>步骤一：选取两个权值最小的2和3，构造一棵二叉树，然后将2和3删除，并将新建的二叉树的5加入到森林中</p><p>步骤二：选取两个权值最小的5和6，构造一棵二叉树，然后将5和6删除，并将新建的二叉树的11加入到森林中</p><p>步骤三：选取两个权值最小的9和11，构造一棵二叉树，然后将9和11删除，并将新建的二叉树的20加入到森林中。此时森林中只有一棵二叉树，所以这棵二叉树就是哈夫曼树</p><p><img src="https://img-blog.csdnimg.cn/20210606165424636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>它的带权路径长度为：2×3+3×3+6×2+9×1=36</p><h3 id="哈夫曼树的构造算法"><a href="#哈夫曼树的构造算法" class="headerlink" title="哈夫曼树的构造算法"></a>哈夫曼树的构造算法</h3><p>在构造哈夫曼树时，我们可以设置一个结构数组HT，用来保存哈夫曼树中各结点的信息。由二叉树的性质可知：==具有n个叶子结点的哈夫曼树共有2n-1个结点，所以数组HT所需要的存储空间为2n-1==，其结构如下：<br><img src="https://img-blog.csdnimg.cn/20210606171203963.png" alt="在这里插入图片描述"><br>其中，weight域用来保存结点的权值，lchild域和rchild域分别用来保存该结点的左，右孩子结点在HT数组中的序号，而parent域则用来判断一个结点是否加入到要建立的哈夫曼树中。初始时令parent值为-1，当结点加入到树中，该结点的parent值为其双亲结点在数组HT中的序号</p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p><strong>构造哈夫曼树时，首先初始化，令2n-1个结点的weight域为0，其它域为-1，然后将n个权值存放到数组HT的前n个分量的weight域中(如下图所示)。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210606185737941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>接着不断将未加入哈夫曼树（即parent域等于-1）的两个权值最小的子树合并成一个较大的子树，每次构成的新子树的根结点按顺序放到HT数组的前n个分量的后面，并修改结点相应域的值。</strong></p><blockquote><p>假设此时数组下标为1和3的权值x2和x4最小，则将它们所构成的新子树的根结点放在HT[n]上，然后将HT[1]和HT[3]的parent域改为新子树的根结点的下标，将HT[n]中的weight域改为x2+x4,将HT[n]中的lchild域改为x2，将HT[n]中的rchild域改为x4</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210606185833775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>假设此时数组下标为2和n-1的权值x3和n最小，则将它们所构成的新子树的根结点放在HT[n+1]上，然后将HT[2]和HT[n-1]的parent域改为新子树的根结点的下标，将HT[n+1]中的weight域改为x3+xn,将HT[n]中的lchild域改为x3，将HT[n]中的rchild域改为xn</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210606185901931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>最终显示哈夫曼树时，只需找到lchild域不为-1的所有结点，然后依次输出它们的weight域和lchild域，weight域和rchild域即可</strong></p><h3 id="哈夫曼树的源代码"><a href="#哈夫曼树的源代码" class="headerlink" title="哈夫曼树的源代码"></a>哈夫曼树的源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 100</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">int</span> lchild, rchild, parent;</span><br><span class="line">&#125;HFMT; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树的初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHFMT</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//下面的for循环是给每个结点初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">HF[i].weight = <span class="number">0</span>;</span><br><span class="line">HF[i].lchild = <span class="number">-1</span>;</span><br><span class="line">HF[i].rchild = <span class="number">-1</span>;</span><br><span class="line">HF[i].parent = <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//下面的for循环给叶子结点的weight域赋初值</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入第%d个结点的权值：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;HF[i].weight);</span><br><span class="line">getchar ();</span><br><span class="line"><span class="comment">//吸收回车键</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到权值最小的两个节点 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Min</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n, <span class="type">int</span>* p, <span class="type">int</span>* r, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Min1 = <span class="number">9999</span>;</span><br><span class="line"><span class="type">int</span> Min2 = <span class="number">9999</span>;</span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="comment">//下面的for循环是为了找到最小的权值所对应的数组下标</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HF[i].parent == <span class="number">-1</span> &amp;&amp; HF[i].weight &lt; Min1)</span><br><span class="line"><span class="comment">//HF[i].parent == -1表示未加入哈夫曼树</span></span><br><span class="line">&#123;</span><br><span class="line">Min1 = HF[i].weight;</span><br><span class="line">*p = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//下面的for循环是为了找到次最小的权值所对应的数组下标</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HF[i].parent == <span class="number">-1</span> &amp;&amp; HF[i].weight &lt; Min2 &amp;&amp; HF[i].weight &gt; Min1)</span><br><span class="line">&#123;</span><br><span class="line">Min2 = HF[i].weight;</span><br><span class="line">*r = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树的创建 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHFMT</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p, r;</span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">InitHFMT (HF, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = n; i &lt; <span class="number">2</span>*n <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Min (HF, n, &amp;p, &amp;r, i);</span><br><span class="line">HF[p].parent = i;</span><br><span class="line">HF[r].parent = i;</span><br><span class="line">HF[i].lchild = HF[p].weight;</span><br><span class="line">HF[i].rchild = HF[r].weight;</span><br><span class="line">HF[i].weight = HF[i].lchild + HF[i].rchild;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisHFMT</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n哈夫曼树的各边显示：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HF[i].lchild != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;(%d, %d), (%d, %d)\n&quot;</span>, HF[i].weight, HF[i].lchild, HF[i].weight, HF[i].rchild);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">HFMT HF[MAX];</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入权值的个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">CreateHFMT (HF, n);</span><br><span class="line">DisHFMT (HF, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://img-blog.csdnimg.cn/20210606210123837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="什么是哈夫曼编码"><a href="#什么是哈夫曼编码" class="headerlink" title="什么是哈夫曼编码"></a>什么是哈夫曼编码</h3><blockquote><p>在进行快速远距离的通信时，经常需要将传送的文字转换成由二进制字符0, 1组成的二进制代码，称之为编码</p></blockquote><p>如果在编码是考虑字符出现的频率，让出现频率高的字符采用短的编码，出现频率低的字符采用长的代码，构造一种不等长编码，则电文的代码就可能更短。哈夫曼编码是一种使电文编码总长最短的编码方案</p><h3 id="生成哈夫曼树编码的方法"><a href="#生成哈夫曼树编码的方法" class="headerlink" title="生成哈夫曼树编码的方法"></a>生成哈夫曼树编码的方法</h3><blockquote><p>要设计长短不同的编码，首先要做到不同字符的编码不会混淆，即任意一个字符的编码都不是另一个字符编码的前缀（即不是另一个字符编码的开头一部分），满足这个条件的编码就是前缀编码。利用哈夫曼树就可以轻松地设计出这种编码</p></blockquote><p>（1）==构造哈夫曼树==。让需要编码的字符作为叶子结点，它们在电文中出现的频率作为它们的权值。<br>（2）==在哈夫曼树上求叶子结点的编码==。规定哈夫曼树中的左分支代表0，右分支代表1，从根结点到每个叶子结点所经过的路径分支组成0和1的序列就是该结点对应字符的编码</p><blockquote><p>在哈夫曼树编码树中，树的带权路径长度的含义是各个字符的码长与其出现的次数的乘积之和，也就是电文的代码总长。采用哈夫曼树构造的代码是一种能使电文代码总长为最短的不等长代码</p></blockquote><p>例如：设有A,B,C,D四个字符，其出现的频率分别为0.10, 0.15, 0.30, 0.45 </p><p><img src="https://img-blog.csdnimg.cn/20210606230050331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>则各个字符的编码为：<br>A:000<br>B:001<br>C;01<br>D:1</p><h3 id="哈夫曼编码的源代码"><a href="#哈夫曼编码的源代码" class="headerlink" title="哈夫曼编码的源代码"></a>哈夫曼编码的源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 100</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">int</span> lchild, rchild, parent;</span><br><span class="line">&#125;HFMT; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树的初始化 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitHFMT</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//下面的for循环是给每个结点初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">HF[i].weight = <span class="number">0</span>;</span><br><span class="line">HF[i].lchild = <span class="number">-1</span>;</span><br><span class="line">HF[i].rchild = <span class="number">-1</span>;</span><br><span class="line">HF[i].parent = <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//下面的for循环给叶子结点的weight域赋初值</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入第%d个结点的权值：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;HF[i].weight);</span><br><span class="line">getchar ();</span><br><span class="line"><span class="comment">//吸收回车键</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到权值最小的两个节点 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Min</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n, <span class="type">int</span>* p, <span class="type">int</span>* r, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Min1 = <span class="number">9999</span>;</span><br><span class="line"><span class="type">int</span> Min2 = <span class="number">9999</span>;</span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="comment">//下面的for循环是为了找到最小的权值所对应的数组下标</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HF[i].parent == <span class="number">-1</span> &amp;&amp; HF[i].weight &lt; Min1)</span><br><span class="line"><span class="comment">//HF[i].parent == -1表示未加入哈夫曼树</span></span><br><span class="line">&#123;</span><br><span class="line">Min1 = HF[i].weight;</span><br><span class="line">*p = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">//下面的for循环是为了找到次最小的权值所对应的数组下标</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (HF[i].parent == <span class="number">-1</span> &amp;&amp; HF[i].weight &lt; Min2 &amp;&amp; HF[i].weight &gt; Min1)</span><br><span class="line">&#123;</span><br><span class="line">Min2 = HF[i].weight;</span><br><span class="line">*r = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树的创建 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHFMT</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p, r;</span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line">InitHFMT (HF, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = n; i &lt; <span class="number">2</span>*n <span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Min (HF, n, &amp;p, &amp;r, i);</span><br><span class="line">HF[p].parent = i;</span><br><span class="line">HF[r].parent = i;</span><br><span class="line">HF[i].lchild = HF[p].weight;</span><br><span class="line">HF[i].rchild = HF[r].weight;</span><br><span class="line">HF[i].weight = HF[i].lchild + HF[i].rchild;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HFnode</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">j = HF[i].parent;</span><br><span class="line"><span class="keyword">if</span> (HF[j].rchild == HF[i].weight)</span><br><span class="line"><span class="comment">//如果它在父母结点的右边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//如果在左边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (HF[j].parent != <span class="number">-1</span>)</span><br><span class="line"><span class="comment">//如果它还有父母结点</span></span><br><span class="line">&#123;</span><br><span class="line">i = j;</span><br><span class="line">HFnode (HF, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HFMTnode</span> <span class="params">(HFMT HF[MAX], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, i, j = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n输入的权值所对应的哈夫曼代码为：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a = i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d的编码为：&quot;</span>, HF[i].weight);</span><br><span class="line">HFnode (HF, i, j);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">i = a; </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">HFMT HF[MAX];</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入权值的个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">CreateHFMT (HF, n);</span><br><span class="line">HFMTnode (HF, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://img-blog.csdnimg.cn/20210606220340100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态查找表</title>
      <link href="/2022/05/15/%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%EF%BC%89/"/>
      <url>/2022/05/15/%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h3 id="顺序查找（又称为线性查找）"><a href="#顺序查找（又称为线性查找）" class="headerlink" title="顺序查找（又称为线性查找）"></a>顺序查找（又称为线性查找）</h3><blockquote><p>顺序查找的线性表定义如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">&#125;Search;</span><br></pre></td></tr></table></figure><p><strong>顺序查找的算法思想：</strong><br>==将顺序表中数据元素存放在数组下标为1到n的位置上，而下标为0的位置空出来作为监视哨，在查找之前，先将要查找的关键字key存放到数组下标为0的位置上，然后从顺序表的最后一个元素开始，从后往前依次和key比较。最终返回数组中与key相等的元素的位置，若返回0，则表示查找失败；若返回非零的整数，则表示查找成功。==</p><p><img src="https://img-blog.csdnimg.cn/2021053123250439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>核心算法如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span> <span class="params">(Search a[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>].key = key;</span><br><span class="line"><span class="comment">//用数组的a[0]元素存放关键字</span></span><br><span class="line"><span class="keyword">while</span> (a[n].key != key)</span><br><span class="line"><span class="comment">//从后往前查找</span></span><br><span class="line">&#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="comment">//返回该元素所在的数组的下标，若下标等于0，则表示表中无此关键字 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>顺序查找的源代码：</strong></p><blockquote><p>举例： 查找值为8的元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">&#125;Search;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqSearch</span> <span class="params">(Search a[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">0</span>].key = key;</span><br><span class="line"><span class="comment">//用数组的a[0]元素存放关键字</span></span><br><span class="line"><span class="keyword">while</span> (a[n].key != key)</span><br><span class="line"><span class="comment">//从后往前查找</span></span><br><span class="line">&#123;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="comment">//返回该元素所在的数组的下标，若下标等于0，则表示表中无此关键字 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Search a[MAX];</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入元素的个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;a[%d] = &quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i].key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = SeqSearch (a, n+<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;表中无此元素！！！&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;该元素的位置为：%d&quot;</span>, i);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210531204110528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="折半查找（又称为二分查找）"><a href="#折半查找（又称为二分查找）" class="headerlink" title="折半查找（又称为二分查找）"></a>折半查找（又称为二分查找）</h3><p><strong>使用折半查找的前提条件：</strong><br>表中的关键字必须按照大小有序排序</p><p><strong>折半查找的算法思想：</strong><br>==取中间元素作为比较对象，若要查找的元素与中间元素相等，则查找成功；若小于中间元素，则到中间元素的左半区继续查找；若大于中间元素，则到中间元素的右半区继续查找。不断重复上述过程，直到查找成功或查找失败。==</p><p><strong>折半查找的主要步骤：</strong><br>（1）初始化查找范围，令low=1，high=n<br>（2）求查找的中间项：mid=(low+high)/2<br>（3）将要查找的关键字和中间项作比较：</p><ul><li>若相等，则查找成功，此时mid指向的位置就是要查找元素的位置</li><li>若k小于关键字，则低位指针low不变，将高位指针high改为mid-1</li><li>若k大于关键字，则高位指针high不变，将低位指针low改为mid+1</li></ul><p> （4）重复步骤(2)和(3)，直到查找成功或查找失败（即low&gt;high）<br>  （5）若查找成功，则返回要查找元素的位置，即当前指针mid;否则返回查找失败标志0</p><blockquote><p>其算法如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找(折半查找)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span> <span class="params">(Search a[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (high &gt;= low)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid].key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">high = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low&gt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找过程举例：</strong></p><blockquote><p>对于关键字序列{2,4,6,9,10,13,18},采用折半查找法查找6和17的具体过程。</p></blockquote><p><strong>（1）查找key=6的过程。</strong><br>初始时令low=1，high=7，则mid=4<br><img src="https://img-blog.csdnimg.cn/20210531224350530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时因为key=6 &lt; a[mid]=9,所以high=mid-1=3, mid=(low+high)/2=2<br><img src="https://img-blog.csdnimg.cn/20210531224741378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时因为key=6 &gt; a[mid]=4,所以low=mid+1=3, mid=(low+high)/2=3<br><img src="https://img-blog.csdnimg.cn/20210531225338175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为此时key=a[mid]=6,所以查找成功，返回mid的值，即返回要查找元素的位置</p><p><strong>（1）查找key=17的过程。</strong><br>初始时令low=1，high=7，则mid=4<br><img src="https://img-blog.csdnimg.cn/20210531225636945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时因为key=17 &gt; a[mid]=9,所以low=mid+1=5, mid=(low+high)/2=6<br><img src="https://img-blog.csdnimg.cn/20210531230211339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时因为key=17 &gt; a[mid]=13,所以low=mid+1=7, mid=(low+high)/2=7<br><img src="https://img-blog.csdnimg.cn/20210531230555879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时因为key=17 &lt; a[mid]=18,所以high=mid-1=6, mid=(low+high)/2=6<br><img src="https://img-blog.csdnimg.cn/20210531231130501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为此时high=6 &lt; low=7,所以查找失败，返回失败标志0</p><p><strong>分块查找的源代码：</strong></p><blockquote><p>举例：查找值为6的元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">&#125;Search;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找(折半查找)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span> <span class="params">(Search a[], <span class="type">int</span> n, <span class="type">int</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span> (high &gt;= low)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].key == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid].key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">high = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low&gt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Search a[MAX];</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入元素的个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;a[%d] = &quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i].key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    i = BinSearch (a, n+<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;该表中无此元素！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;该元素的位置为：%d&quot;</span>, i);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210531232843950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="分块查找（又称为索引顺序查找）"><a href="#分块查找（又称为索引顺序查找）" class="headerlink" title="分块查找（又称为索引顺序查找）"></a>分块查找（又称为索引顺序查找）</h3><p>使用分块查找的前提条件：<br><strong>将查找表分成若干块，每块中的元素存储顺序都是任意的，但块与块之间必须按照关键字的大小有序排列，即前一块的最大关键字要小于后一块中的最小关键字。</strong></p><p>基本准备：<br><strong>建立一个索引表，索引表的每一项对应线性表的一块，索引项由关键字域和指针域组成，关键字域存放相应块的最大关键字，指针域存放指向块内的第一个元素和最后一个元素的数组下标值。</strong></p><blockquote><p>分块查找的线性表类型与顺序查找的类型相同，但是还需要定义一个索引表类型</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引表类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> low, high, key;</span><br><span class="line"><span class="comment">//low表示块内低地址，high表示块内高地址，key表示块内最大关键字</span></span><br><span class="line">&#125;TypeIdx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">&#125;Search;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以设计一个数组a来存放关键字的信息，设计一个数组b来存放索引表的信息<br>举例：对于关键字序列{6,12,7,10,9,22,15,20,18,26}，我们可以将其分为两块，即{6,12,7,10,9}和{22,15,20,18,26}，前一块的最大关键字12小于后一块的最小关键字15</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210531164409283.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210531164444765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>分块查找的算法思想：</strong><br>==先采用折半查找法确定待查找元素属于哪一块(由于索引表是递增有序的，所以采用折半查找速度较快),再采用顺序查找法查找块内的元素。(由于每块内的元素个数少，所以对执行速度没有太大的影响)==</p><blockquote><p>因为索引表需要根据线性表中的个元素的值来生成，所以为了生成索引表，要编写建立索引表的函数，其算法如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立索引表 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateIdx</span> <span class="params">(Search a[], TypeIdx b[], <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line"><span class="comment">//m表示元素的总数，n表示每块中的元素个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, k, max;</span><br><span class="line"><span class="comment">//用i表示a数组的下标值，k表示b数组的下标值</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; m; i = i+n, k++)</span><br><span class="line"><span class="comment">//用for循环将每块的最大关键字，低地址和高地址都确定下来</span></span><br><span class="line">&#123;</span><br><span class="line">max = a[i].key;</span><br><span class="line"><span class="comment">//先将最大值设为第i个元素</span></span><br><span class="line"><span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; i+n &amp;&amp; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j].key &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = a[j].key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b[k].key = max;</span><br><span class="line"><span class="comment">//确定该块的最大值元素</span></span><br><span class="line"></span><br><span class="line">b[k].low = i;</span><br><span class="line"><span class="comment">//确定该块的低地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i+n &lt;= m)</span><br><span class="line"><span class="comment">//当最后一块的长度小于n时</span></span><br><span class="line">&#123;</span><br><span class="line">b[k].high = i+n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[k].high = m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确定该块的高地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在线性表中查找关键字为k的元素。若找到，则返回它所在的位置；否则返回-1，其算法如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BlkSearch</span> <span class="params">(<span class="type">int</span> f, Search a[], TypeIdx b[], <span class="type">int</span> k)</span></span><br><span class="line"><span class="comment">//f是索引表的元素个数，k是要查找的关键字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, mid;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = f;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (b[mid].key &gt; k)</span><br><span class="line">&#123;</span><br><span class="line">high = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[mid].key &lt; k)</span><br><span class="line">&#123;</span><br><span class="line">low = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">low = mid; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用二分法找到要查找元素的所在块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">i = b[low].low;</span><br><span class="line">    j = b[low].high;</span><br><span class="line"><span class="comment">//将该块低，高地址分别赋值给i,j</span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i].key != k)</span><br><span class="line">    &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//i表示要查找元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>分块查找的源代码：</strong></p><blockquote><p>举例：对于关键字序列{6,12,7,10,9,22,15,20,18,26}，我们来查找关键字为9的元素</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引表类型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> low, high, key;</span><br><span class="line"><span class="comment">//low表示块内低地址，high表示块内高地址，key表示块内最大关键字</span></span><br><span class="line">&#125;TypeIdx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line">&#125;Search;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立索引表 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateIdx</span> <span class="params">(Search a[], TypeIdx b[], <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line"><span class="comment">//m表示元素的总数，n表示每块中的元素个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, k, max;</span><br><span class="line"><span class="comment">//用i表示a数组的下标值，k表示b数组的下标值</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; m; i = i+n, k++)</span><br><span class="line"><span class="comment">//用for循环将每块的最大关键字，低地址和高地址都确定下来</span></span><br><span class="line">&#123;</span><br><span class="line">max = a[i].key;</span><br><span class="line"><span class="comment">//先将最大值设为第i个元素</span></span><br><span class="line"><span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; i+n &amp;&amp; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j].key &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = a[j].key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b[k].key = max;</span><br><span class="line"><span class="comment">//确定该块的最大值元素</span></span><br><span class="line"></span><br><span class="line">b[k].low = i;</span><br><span class="line"><span class="comment">//确定该块的低地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i+n &lt;= m)</span><br><span class="line"><span class="comment">//当最后一块的长度小于n时</span></span><br><span class="line">&#123;</span><br><span class="line">b[k].high = i+n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[k].high = m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确定该块的高地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印索引表 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisIdx</span> <span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, Search a[], TypeIdx b[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;建立的顺序表为：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d    &quot;</span>, a[i].key);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CreateIdx (a, b, m, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n索引表信息如下:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;低地址    高地址   最大关键字\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m/n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;   %d         %d         %d\n&quot;</span>, b[i].low, b[i].high, b[i].key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BlkSearch</span> <span class="params">(<span class="type">int</span> f, Search a[], TypeIdx b[], <span class="type">int</span> k)</span></span><br><span class="line"><span class="comment">//f是索引表的元素个数，k是要查找的关键字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, mid;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = f;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (b[mid].key &gt; k)</span><br><span class="line">&#123;</span><br><span class="line">high = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[mid].key &lt; k)</span><br><span class="line">&#123;</span><br><span class="line">low = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">low = mid; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用二分法找到要查找元素的所在块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">i = b[low].low;</span><br><span class="line">    j = b[low].high;</span><br><span class="line"><span class="comment">//将该块低，高地址分别赋值给i,j</span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i].key != k)</span><br><span class="line">    &#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//i表示要查找元素的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Search a[MAX];</span><br><span class="line">TypeIdx b[MAX];</span><br><span class="line"><span class="type">int</span> m, i, n, f;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入元素的个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请依次输入各个元素(要求块内无序，块间有序)\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i].key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n请输入索引表每块的大小为：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">DisIdx (m, n, a, b);</span><br><span class="line">  </span><br><span class="line"> f = <span class="built_in">ceil</span> (m/n);</span><br><span class="line"><span class="comment">//f为大于或等于m/n的最小整数 </span></span><br><span class="line"> i = BlkSearch (f, a, b, <span class="number">9</span>);</span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span> (<span class="string">&quot;\n表中无此元素！！！&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n该元素在表中的位置为：%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="https://img-blog.csdnimg.cn/20210531200630688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="三种查找算法的比较"><a href="#三种查找算法的比较" class="headerlink" title="三种查找算法的比较"></a>三种查找算法的比较</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th><th>平均性能</th></tr></thead><tbody><tr><td>顺序查找</td><td>对表中的数据如何存储没有要求</td><td>平均查找长度较大，效率低</td><td>差</td></tr><tr><td>折半查找</td><td>比较次数少，查找速度快</td><td>要求待查找的表必须为有序表，而且排序会很费时</td><td>好</td></tr><tr><td>分块查找</td><td>只要找到相应的块，插入或删除元素很容易</td><td>要求待查找的表，块与块之间必须按关键字的大小有序排列</td><td>介于二者之间</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的层次遍历详解</title>
      <link href="/2022/05/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
      <url>/2022/05/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是层次遍历呢？"><a href="#什么是层次遍历呢？" class="headerlink" title="什么是层次遍历呢？"></a>什么是层次遍历呢？</h3><p>按照我的理解，==层次遍历就是从上到下，从左往右，一层层的遍历==<br>如下图，层次遍历的结果是：ABCDEF<br><img src="https://img-blog.csdnimg.cn/20210515181828635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>图片来源于<a href="">https://blog.csdn.net/hansionz/article/details/81947834</a></p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先定义一个循环队列，使这个队中的数据域能存放二叉树中的元素。==元素入队后，就输出队头元素的值，然后让队头元素出队，并将其的左右孩子依次入队……周而复始地进行同样的操作，直到队为空。最终，出队的顺序就是层次遍历的顺序。==</p><p><em>听完是不是还是有点蒙？没事，我们来看核心代码帮助理解</em></p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Leave</span> <span class="params">(BT* t)</span> </span><br><span class="line">&#123;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="comment">//定义一个循环队列</span></span><br><span class="line">Q.head = <span class="number">0</span>;</span><br><span class="line">Q.rear = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环队列初始化</span></span><br><span class="line"><span class="comment">//队为空的条件：队头等于队尾 </span></span><br><span class="line">    BT* temp;</span><br><span class="line"><span class="comment">//定义一个二叉树类型的指针    </span></span><br><span class="line">PushQueue (&amp;Q, *t);</span><br><span class="line"><span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (EmptyQueue (&amp;Q))</span><br><span class="line"><span class="comment">//当队不为空时，循环    </span></span><br><span class="line">&#123;</span><br><span class="line">*temp = Q.data[Q.head+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//将队头元素赋值给变量*temp</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="comment">//输出队头元素的值</span></span><br><span class="line">PopQueue (&amp;Q);</span><br><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//如果左孩子不为空，则左子树入队        </span></span><br><span class="line">&#123;</span><br><span class="line">PushQueue (&amp;Q, *temp-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果右孩子不为空，则右子树入队    </span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushQueue (&amp;Q, *temp-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>以图片中的字母为二叉树的元素，则运行结果应该为ABCDEF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">//定义数组的长度为100 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的结点定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的结点定义 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="comment">//head为头</span></span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line"><span class="comment">//rear为尾</span></span><br><span class="line">BT data[MAX];</span><br><span class="line"><span class="comment">//data为二叉树类型的数组,能存放二叉树中的元素</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个二叉树 </span></span><br><span class="line">BT* <span class="title function_">CreateTree</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">BT* t;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%c&quot;</span>, &amp;ch); </span><br><span class="line">getchar ();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t = (BT*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (BT));</span><br><span class="line">t-&gt;data = ch;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入%c的左子树：&quot;</span>, t-&gt;data);</span><br><span class="line">t-&gt;lchild = CreateTree ();</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入%c的右子树：&quot;</span>, t-&gt;data);</span><br><span class="line">t-&gt;rchild = CreateTree();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队是否为空</span></span><br><span class="line"><span class="comment">//队不为空则返回1，队空则返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EmptyQueue</span> <span class="params">(LinkQueue* Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;head == Q-&gt;rear)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushQueue</span> <span class="params">(LinkQueue* Q, BT t)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%MAX;</span><br><span class="line">Q-&gt;data[Q-&gt;rear] = t;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PopQueue</span> <span class="params">(LinkQueue* Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;head = (Q-&gt;head+<span class="number">1</span>)%MAX;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Leave</span> <span class="params">(BT* t)</span> </span><br><span class="line">&#123;</span><br><span class="line">LinkQueue Q;</span><br><span class="line"><span class="comment">//定义一个循环队列</span></span><br><span class="line">Q.head = <span class="number">0</span>;</span><br><span class="line">Q.rear = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//循环队列初始化</span></span><br><span class="line"><span class="comment">//队为空的条件：队头等于队尾 </span></span><br><span class="line">    BT* temp;</span><br><span class="line"><span class="comment">//定义一个二叉树类型的指针    </span></span><br><span class="line">PushQueue (&amp;Q, *t);</span><br><span class="line"><span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (EmptyQueue (&amp;Q))</span><br><span class="line"><span class="comment">//当队不为空时，循环    </span></span><br><span class="line">&#123;</span><br><span class="line">*temp = Q.data[Q.head+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//将队头元素赋值给变量*temp</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>, temp-&gt;data);</span><br><span class="line"><span class="comment">//输出队头元素的值</span></span><br><span class="line">PopQueue (&amp;Q);</span><br><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">//如果左孩子不为空，则左子树入队        </span></span><br><span class="line">&#123;</span><br><span class="line">PushQueue (&amp;Q, *temp-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果右孩子不为空，则右子树入队    </span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PushQueue (&amp;Q, *temp-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">BT* t;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请按先序依次输入树的结点！！！\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入根节点：&quot;</span>); </span><br><span class="line">t = CreateTree ();</span><br><span class="line">Leave (t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>注意：#表示空的意思<br><img src="https://img-blog.csdnimg.cn/20210515194005819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符</title>
      <link href="/2022/05/15/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%EF%BC%8C%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%20%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/"/>
      <url>/2022/05/15/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%EF%BC%8C%E5%85%B3%E7%B3%BB%EF%BC%8C%E9%80%BB%E8%BE%91%EF%BC%8C%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%20%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98">TOC</a></p><h1 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h1><p>  ＋(加),  －(减) ,   *(乘)  ,   /(除) ,   %(求余)</p><h3 id="除法运算的注意事项"><a href="#除法运算的注意事项" class="headerlink" title="除法运算的注意事项"></a>除法运算的注意事项</h3><ol><li>被除数和除数都是int类型，则商一定是整数（原因：如果商是小数，结果会自动舍去小数点后面的数字）<br>例如：<pre><code>  16 / 4 = 4 16 / 5 = 3</code></pre></li><li>被除数和除数只要有一个是float类型，则商也是小数（原因：如果商是小数，结果也会保留小数点后面的数字）<br>例如: <pre><code> 16 / 4.0 = 4.0  16.0 / 4 = 4.0  16.0 / 5 = 3.2 16 / 5.0 = 3.2</code></pre></li></ol><p>典型例题：求s = 1 + 1/2 + 1/3 + …+1/100的值</p><h3 id="求余运算的注意事项"><a href="#求余运算的注意事项" class="headerlink" title="求余运算的注意事项"></a>求余运算的注意事项</h3><ul><li>求余的运算对象必须都是整数</li><li>==求余的符号与被求余的数的符号一致==<br>  例如：<br> 13 % 3 = 1<br> 13 % -3 = 1<br> -13 % 3 = -1</li></ul><p>验证的小例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, <span class="number">13</span>%<span class="number">3</span>);<span class="comment">//结果：1 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, <span class="number">-13</span>%<span class="number">3</span>);<span class="comment">//结果：-1 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, <span class="number">13</span>%<span class="number">-3</span>);<span class="comment">//结果：1 </span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h1 id="（2）关系运算符"><a href="#（2）关系运算符" class="headerlink" title="（2）关系运算符"></a>（2）关系运算符</h1><p> &lt;(小于)，    &gt;(大于)，   ==（等于），  !=(不等于)，<br> ＜=(小于等于)  ，  &gt;=(大于等于)</p><p><em>“=”与”==”的区别：</em><br> <strong>“=”的意思是将右边的东西赋值给左边</strong></p><p> <strong>而”==”的意思就是数学意义上的等于</strong></p><h1 id="（3）逻辑运算符"><a href="#（3）逻辑运算符" class="headerlink" title="（3）逻辑运算符"></a>（3）逻辑运算符</h1><p>  ||(或) ,  &amp;&amp;(且),   !（非）</p><p> 该逻辑运算符与数学的或且非符号对真假的判定方法一致</p><ul><li>&amp;&amp;左右两边的表达式均为真，则总判断为真</li><li>||左右两边的表达式只要有一个为真的，则总判断为真</li></ul><p> C语言对真假的处理: </p><ul><li>（1）非零则真，零则假;</li><li>（2）真用1表示，假用0表示</li></ul><p>（1）验证的小例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-5</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;嘻嘻&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;呵呵&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//结果:哈哈嘻嘻 </span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>（2）验证的小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a = (<span class="number">3</span>&gt;<span class="number">2</span>) &amp;&amp; (<span class="number">5</span>&lt;<span class="number">4</span>);<span class="comment">//整体为假</span></span><br><span class="line">b = (<span class="number">3</span>&gt;<span class="number">2</span>) || (<span class="number">5</span>&lt;<span class="number">4</span>);<span class="comment">//整体为真</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;a=%d&quot;</span>, a);<span class="comment">//结果：a=0 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;b=%d&quot;</span>, b);<span class="comment">//结果：b=1 </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="（4）赋值运算符"><a href="#（4）赋值运算符" class="headerlink" title="（4）赋值运算符"></a>（4）赋值运算符</h1><p>  ＝ , ＋＝ , －＝ , *＝,  /＝ </p><p>  对于a ＋= 3；它等价于 a  =  a＋3；<br>    对于a  *= 3；它等价于 a  = a *  3；</p><p>==优先级别：算术&gt;关系&gt;逻辑&gt;赋值==</p><h1 id="（5）自增运算符"><a href="#（5）自增运算符" class="headerlink" title="（5）自增运算符"></a>（5）自增运算符</h1><h3 id="前自增和后自增的相同点及不同点"><a href="#前自增和后自增的相同点及不同点" class="headerlink" title="前自增和后自增的相同点及不同点"></a>前自增和后自增的相同点及不同点</h3><p>   前自增 ++i  ，后自增 i++<br>    相同点：==都使i的值加1==<br>    不同点：<br>==前自增使表达式的值为i+1之后的值<br>后自增使表达式的值为i+1之前的值==<br>验证的小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = <span class="number">5</span>;</span><br><span class="line">b = a++;</span><br><span class="line">c = ++a;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;a=%d&quot;</span>, a);<span class="comment">//结果：a=7（前自增和后自增使a加了两次1） </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;b=%d&quot;</span>, b);<span class="comment">//结果：b=5 (后自增使b的值为a+1之前的值)</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;c=%d&quot;</span>, c);<span class="comment">//结果：c=7 （前自增使c的值为a+1之后的值）</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="使用该运算符的注意事项"><a href="#使用该运算符的注意事项" class="headerlink" title="使用该运算符的注意事项"></a>使用该运算符的注意事项</h3><p>   该运算符应单独使用，不要将它作为表达式的一部分<br>   使用时应屏蔽掉前自增和后自增的差别</p><h3 id="使用该运算符的好处"><a href="#使用该运算符的好处" class="headerlink" title="使用该运算符的好处"></a>使用该运算符的好处</h3><p>使代码更简练<br>该运算符的运算速度更快</p><h1 id="（6）三目运算符"><a href="#（6）三目运算符" class="headerlink" title="（6）三目运算符"></a>（6）三目运算符</h1><p>格式：（A ? B : C）<br>等价于<br>if （A）<br>B；<br>else<br>C；<br>即如果式子A成立，则执行B；如果不成立，则执行C</p><p>验证的小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line">(a&gt;<span class="number">0</span> ? a++ : a--) ;</span><br><span class="line">(b&gt;<span class="number">0</span> ? b++ : b--);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;a=%d&quot;</span>, a);<span class="comment">//结果：a=2 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;b=%d&quot;</span>, b);<span class="comment">//结果：b=-2 </span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h1 id="（7）逗号表达式"><a href="#（7）逗号表达式" class="headerlink" title="（7）逗号表达式"></a>（7）逗号表达式</h1><p>格式：（A，B，C，D）<br>功能：从左到右执行<br>最终表达式的值为最后一个式子的值<br>验证小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">j = (i++, i+<span class="number">3</span>, i++, i<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;j=%d&quot;</span>, j);<span class="comment">//结果：j=3 </span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表之头插法和尾插法详解（C语言版）</title>
      <link href="/2022/05/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/"/>
      <url>/2022/05/10/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h1><p>核心代码：<br>head-&gt;next = NULL;<br>s-&gt;next = head-&gt;next;<br>head-&gt;next = s;</p><p>单个结点<br><img src="https://img-blog.csdnimg.cn/20210527190102687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>原始状态<br><img src="https://img-blog.csdnimg.cn/20210525231312227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>第一个元素插入的过程（注意：1和2的顺序不能颠倒，不然会导致链表缺失）</p><p><img src="https://img-blog.csdnimg.cn/20210525231358801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"><br>第一个元素插入后<br><img src="https://img-blog.csdnimg.cn/20210527104348204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>第二个元素插入的过程（其余元素插入的过程也类似）</p><p><img src="https://img-blog.csdnimg.cn/20210525231416277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"><br>第二个元素插入后</p><p><img src="https://img-blog.csdnimg.cn/20210527104629294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><h1 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h1><p>核心代码：<br>tail = head;<br>s-&gt;next = NULL;<br>tail-&gt;next = s;<br>tail = s;</p><p> 原始状态<br> <img src="https://img-blog.csdnimg.cn/20210525231439859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>第一个元素插入的过程（注意：2和3的顺序不能颠倒，不然会导致链表的生成出错）</p><p><img src="https://img-blog.csdnimg.cn/20210525231453394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"><br>第一个元素插入后<br><img src="https://img-blog.csdnimg.cn/20210527104912241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>第二个元素插入的过程（其余元素插入的过程也类似）</p><p><img src="https://img-blog.csdnimg.cn/20210525231506685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"><br>第二个元素插入后<br><img src="https://img-blog.csdnimg.cn/20210527105127951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><h1 id="头插法和尾插法的对比"><a href="#头插法和尾插法的对比" class="headerlink" title="头插法和尾插法的对比"></a>头插法和尾插法的对比</h1><p>头插法建立链表的算法简短易懂，但是生成链表的结点顺序与原来输入的顺序相反，而用尾插法建立链表可使输入和生成的结点顺序相同</p><p><strong>为什么会这样呢？</strong><br>根据上面的头插法和尾插法的算法，我们很容易知道，当用<strong>头插法</strong>依次插入值分别为1,2,3,4,5的结点（也叫做元素）后，单链表会如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210527191947873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"></p><p>但是用<strong>尾插法</strong>同样插入值分别为1,2,3,4,5的结点后，单链表却会如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210527191734786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyNjA3ODM0,size_16,color_FFFFFF,t_70"><br>而在这两个链表中，<strong>输出链表中各个元素的值只能从已知的头结点head开始遍历，所以分别用头插法和尾插法创建链表后，依次输出的元素的值刚好是相反的</strong></p><hr><p>验证小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"> &#125;LinkList; </span><br><span class="line"> <span class="comment">//定义LinkList为struct node类型，即struct node可直接用LinkList来表示，方便定义</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//头插法创建单链表 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, len = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//len表示链表的长度</span></span><br><span class="line">LinkList* head, * s;</span><br><span class="line"><span class="comment">//head为LinkList*类型的指针变量，表示头指针</span></span><br><span class="line">head = (LinkList*)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line"><span class="comment">//malloc (sizeof (LinkList))意思是让系统分配内存大小为sizeof (LinkList)的空间</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//令头指针的所指向结点的指针域为空</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s = (LinkList*)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入该元素的值:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;data);</span><br><span class="line">s-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下代码是为了将单链表中各个元素的值依次打印出来</span></span><br><span class="line">LinkList* q;</span><br><span class="line">q = (LinkList*)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line">q = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, q-&gt;data);</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:<br>请输入该元素的值:1<br>请输入该元素的值:2<br>请输入该元素的值:3<br>请输入该元素的值:4<br>请输入该元素的值:5<br>54321</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"> &#125;LinkList; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//尾插法创建单链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, len = <span class="number">5</span>;</span><br><span class="line">LinkList* head,* s,* tail;</span><br><span class="line"><span class="comment">//tail表示尾指针</span></span><br><span class="line">head = (LinkList*)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line">tail = head;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">s = (LinkList*)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (LinkList));</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;请输入该元素的值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;data); </span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail-&gt;next = s;</span><br><span class="line">tail = s;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//以下代码是将单链表中各个元素的值依次打印出来   </span></span><br><span class="line">    LinkList* q;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, q-&gt;data);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>结果：<br>请输入该元素的值：1<br>请输入该元素的值：2<br>请输入该元素的值：3<br>请输入该元素的值：4<br>请输入该元素的值：5<br>12345</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
